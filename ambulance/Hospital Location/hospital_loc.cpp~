#include "hospital_loc.h"



// Find s Distance between two points
float find_distance(point a, point b){
	return pow(pow((a.x-b.x),2) + pow((a.y-b.y),2),0.5);
}

// Checks if old_centeroids and  new_centeroids are same or not
bool check_change(vector<point> old_centeroids, vector<point> new_centeroids){
	if(old_centeroids.size()!=new_centeroids.size()){
		cout<< "Error";
		//return;
	}
	
	for(int i=0 ; i < old_centeroids.size(); ++i){
		if((old_centeroids[i].x != new_centeroids[i].x) || (old_centeroids[i].y != new_centeroids[i].y))
			return 1;
	}
	// else case when all old_centeroids == new_centeroids
	return 0;
}

// returns the nodes closest to mean for each of the clusters in clusterlist
vector<point> mean_of_cluster(vector<vector<point> > clusterList, int k){
	point sum, mean,candidate;
	vector<float> distance;
	float min_distance;
	vector<point> new_centeroids;


	for (int i = 0; i < clusterList.size(); ++i){	
		sum.x = 0;
		sum.y = 0;

		for (int j = 0; j < clusterList[i].size(); ++j){
			sum.x = sum.x + clusterList[i][j].x;
			sum.y = sum.y + clusterList[i][j].y;
		}

		mean.x = sum.x / k;
		mean.y = sum.y / k;

		// have to find the closest node to this mean
		distance.clear();
		min_distance = find_distance(mean, clusterList[i][0]);// assumption
		candidate = clusterList[i][0];
		for (int n = 0; n < clusterList[i].size(); ++n)
		{
			distance.push_back(find_distance(mean, clusterList[i][n]));
			if(distance[n] < min_distance){
				min_distance = distance[n];
				candidate = clusterList[i][n];
			} 
		}

		new_centeroids.push_back(candidate);		
	}
	return new_centeroids;
}

void print(vector<vector<point> > clusterList)
{
	cout << "Printing" << endl;
		for (int i = 0; i < clusterList.size(); ++i){
			cout<< "\n" << i <<":";
			for (int j = 0; j < clusterList[i].size(); ++j)
			{
				cout<<clusterList[i][j].x<<", "<<clusterList[i][j].y<<"; ";
			}
		}


}
// Performs K-means clustering
vector<vector<point> > kmeans(vector<point> initcluster, int k){
	
	vector<point> centeroids, old_centeroids; // vector maintaining k centeroids
  	vector<vector<point> > clusterList; // for storing the list of clusters
  	vector<float> distance; // temp vector, used for finding the min_distance
  	int centeroids_change = 1; //Flag which helps the loop to terminate 
  	float min;
  	int destination,num = 0;

  	// Intial centeroids are random
	for(int i = 0; i < k; ++i){
		centeroids.push_back(initcluster[i]);
	}
	// loop for finding the optimal clusters and centeroids
	//while(centeroids_change){
	while(num <1500){ // assumption, will consider 1250 loops as near optimal solution
		clusterList.clear(); // clearing the datastructure, after last loop.
		
		// initializing the clusterList
		vector<point> v;
		for (int i = 0; i < k; ++i)
		{
			clusterList.push_back(v);
		}
	
		for (int i = 0; i < initcluster.size()-1; ++i){	
			distance.clear();// will empty the distance vector for future calculations
			
			min = find_distance(initcluster[i], centeroids[0]); //assumption, will improve while running the code
			destination = 0;
		
			for (int j = 0; j < centeroids.size(); ++j){
				distance.push_back(find_distance(initcluster[i], centeroids[j]));
				if (distance[j] <= min){  
					min = distance[j];
					destination = j;
				}	
			}	
			clusterList.at(destination).push_back(initcluster[i]);						
		}
	
		num ++;
		old_centeroids = centeroids;
	
		centeroids = mean_of_cluster(clusterList, k);
		//centeroids_change = check_change(old_centeroids, centeroids);
	}

	cout<< "Number of loops iterated for finding Optimal Solution: "<< num<<"\n";
	
	//print(clusterList);

	// Printing final K centeroids
	cout << "Final Centeroids:"<<"\n";
	for(int i=0; i <centeroids.size();++i){
		cout<<centeroids[i].x<<", "<<centeroids[i].y<<"; "<<"\n";
	}

	return clusterList;
}

